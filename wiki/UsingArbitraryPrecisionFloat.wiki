#summary This page is a quick introduction for using/playing-with ArbitraryPrecisionFLoat

= Introduction =

To play with ArbitraryPrecisionFloat, an easy way is to follow these lines, copy/paste some code in a Smalltalk workspace and doIt/printIt. The expected results are indicated in *bold*.


= Details =

The first thing is to create an ArbitraryPrecisionFloat. This is generally obtained by converting another Smalltalk Number.
{{{1 asArbitraryPrecisionFloatNumBits: 200.}}}<br>
{{{11/3 asArbitraryPrecisionFloatNumBits: 200.}}}

Like another Float, an ArbitraryPrecisionFloat is inexact, but you can control the precision:
  {{{((1/3) asFloatD asFraction - (1/3)) asFloatD.}}} -> *-1.850371707708594e-17*<br>
  {{{((1/3 asArbitraryPrecisionFloatNumBits: 200) asFraction - (1/3)) asFloatD.}}} -> *1.037169212976857e-61*

Once you created an ArbitraryPrecisionFloat, you just act on it as with any other Smalltalk Number.
  {{{| a b |}}}<br>
  {{{a := 1/3 asArbitraryPrecisionFloatNumBits: 100.}}}<br>
  {{{b := 2 asArbitraryPrecisionFloatNumBits: 100.}}}<br>
  {{{^b sqrt * a.}}}<br>
  -> *(ArbitraryPrecisionFloat readFrom: '0.471404520791031682933896241403' readStream numBits: 100)*

You can mix inexact and exact operands, in which case the result is inexact:
  {{{(1 asArbitraryPrecisionFloatNumBits: 16) + (1/3).}}}<br>
  -> * (ArbitraryPrecisionFloat readFrom: '1.33334' readStream numBits: 16)*

You can mix precisions, in which case the operands are converted to higher precision:
  {{{(1/3 asArbitraryPrecisionFloatNumBits: 16) - (1/3 asArbitraryPrecisionFloatNumBits: 24).}}}<br>
  -> *(ArbitraryPrecisionFloat readFrom: '2.53e-6' readStream numBits: 24)*<br>
  _What you see here, is again the result of inexact conversion of the Fraction 1/3 into a Float in base 2._<br>
  _The rounding error of course depends on the precision._

You can play with the digits of pi, by just writing this snippet:
  {{{(0 asArbitraryPrecisionFloatNumBits: 320) pi.}}}<br>
  -> * (ArbitraryPrecisionFloat readFrom: '3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117' readStream numBits: 320)*<br>
  _Note that 10 binary digits are roughly equivalent to 3 decimal digits (2^10=1024), thus we effectively get around 96 decimal digits with 320 bits._<br>
  _Also remember that the last digit is not exact, it suffers both from the rounding error for pi, and another rounding error for the base2 -> base 10 conversion, thus the last digit(s) might change if you ask for a few more digits._

A requirement for ArbitraryPrecisionFloat mathematical functions is to differ from exact result by no more than half a unit of least precision. This is much stricter than IEEE 754 which has relaxed these requirements (probably to fit existing hardware/software floating point implementations). Also remind that ArbitraryPrecisionFloat can afford to be slow. Your machine optimized Floating points have different trade off - they must be fast. Thus the results of ArbitraryPrecisionFloat may differ from your floating point math library, but don't trust your math library too much.
For example, in Squeak on MacOSX:
  {{{7 asFloatD ln storeString.}}} -> *'1.9459101490553135'*<br>
  {{{(7 asArbitraryPrecisionFloatNumBits: Float precision) ln.}}}<br>
  -> *(ArbitraryPrecisionFloat readFrom: '1.9459101490553132' readStream numBits: 53)*<br>
  _Though we could expect same results on such a simple case..._<br><br>
  _The result is confirmed by increasing precision:_<br>
  {{{(7 asArbitraryPrecisionFloatNumBits: 70) ln.}}}<br>
  -> *(ArbitraryPrecisionFloat readFrom: '1.945910149055313305106' readStream numBits: 70)*<br><br>
  _The value rounded to 53 bits is correct:_<br>
  {{{(7 asArbitraryPrecisionFloatNumBits: 70) ln asFloatD storeString.}}}<br>
  -> *'1.9459101490553132'*<br>
  _Note, that the last digit is not guaranteed to match correct decimal rounding, the decimal representation is only expected to give back exactly the original value when rounded to base 2, and both 1.9459101490553132 and 1.9459101490553133 do._<br><br>
  _The difference is less than 1/2 ulp for the ArbitraryPrecisionFloat result:_<br>
  {{{((7 asArbitraryPrecisionFloatNumBits: 70) ln - (7 asArbitraryPrecisionFloatNumBits: 53) ln)}}}<br>
  {{{   / (7 asFloatD ln ulp).}}}<br>
  -> *(ArbitraryPrecisionFloat readFrom: '0.32983' readStream numBits: 70)*<br><br>
  _And more than 1/2 ulp for the FloatD result:_<br>
  {{{((7 asArbitraryPrecisionFloatNumBits: 70) ln - (7 asFloatD ln)) / (7 asFloatD ln ulp).}}}
  -> *(ArbitraryPrecisionFloat readFrom: '-0.67017' readStream numBits: 70)*<br><br>
  _Note that *#ulp* is a Squeakism meaning unit of least precision, but you might find equivalent messages in other dialects._
That's all for this short introduction, let's hope that you'll find a good usage of this class, or at least that these examples will provide educational benefits.