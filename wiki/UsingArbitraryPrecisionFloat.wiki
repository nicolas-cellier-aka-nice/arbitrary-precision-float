#summary This page is a quick introduction for using/playing-with ArbitraryPrecisionFLoat

= Introduction =

To play with ArbitraryPrecisionFloat, an easy way is to follow these lines, copy/paste some code in a Smalltalk workspace and doIt/printIt. The expected results are indicated in *bold*.


= Details =

The first thing is to create an ArbitraryPrecisionFloat. This is generally obtained by converting another Smalltalk Number.
  {{{1 asArbitraryPrecisionFloatNumBits: 200.}}}<br>
  {{{1/3 asArbitraryPrecisionFloatNumBits: 200.}}}

Like another Float, an ArbitraryPrecisionFloat is inexact, but you can control the precision:
  {{{((1/3) asFloatD asFraction - (1/3)) asFloatD.}}} -> *-1.850371707708594e-17*<br>
  {{{((1/3 asArbitraryPrecisionFloatNumBits: 200) asFraction - (1/3)) asFloatD.}}} -> *1.037169212976857e-61*

Once you created an ArbitraryPrecisionFloat, you just act on it with any other Smalltalk Number.
  {{{| a b |}}}<br>
  {{{a := 1/3 asArbitraryPrecisionFloatNumBits: 100.}}}<br>
  {{{b := 2 asArbitraryPrecisionFloatNumBits: 100.}}}<br>
  {{{^b sqrt * a.}}}<br>
  -> *(ArbitraryPrecisionFloat readFrom: '0.471404520791031682933896241403' readStream numBits: 100)*

You can mix inexact and exact operands, in which case the result is inexact:
  {{{(1 asArbitraryPrecisionFloatNumBits: 16) + (1/3).}}}<br>
  -> * (ArbitraryPrecisionFloat readFrom: '1.33334' readStream numBits: 16)*

You can mix precisions, in which case the operands are converted to higher precision:
  {{{(1/3 asArbitraryPrecisionFloatNumBits: 16) - (1/3 asArbitraryPrecisionFloatNumBits: 24).}}}<br>
  -> *(ArbitraryPrecisionFloat readFrom: '2.53e-6' readStream numBits: 24)*<br>
  What you see here, is again the result of inexact conversion of the Fraction 1/3 into a Float in base 2.<br>
  The rounding error of course depends on the precision.

You can play with the digits of pi, by just writing this snippet:
  {{{(0 asArbitraryPrecisionFloatNumBits: 500) pi.}}}<br>
  -> * (ArbitraryPrecisionFloat readFrom: '3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940813' readStream numBits: 500)*<br>
  Of course, the last digit is rounded, and might change if you ask for a few more digits.

A requirement for ArbitraryPrecisionFloat mathematical functions is to differ from exact result by no more than half a unit of least precision. This is much stricter than IEEE 754 which has relaxed these requirements (probably to fit existing hardware/software floating point implementations). Also remind that ArbitraryPrecisionFloat can afford to be slow. Your machine optimized Floating points have different trade off - they must be fast. Thus the results of ArbitraryPrecisionFloat may differ from your floating point math library, but don't trust your math library too much.
For example, in Squeak on MacOSX:
  {{{7 asFloatD ln storeString.}}} -> *'1.9459101490553135'*<br>
  {{{(7 asArbitraryPrecisionFloatNumBits: Float precision) ln.}}}<br>
  -> *(ArbitraryPrecisionFloat readFrom: '1.9459101490553132' readStream numBits: 53)*<br>
  Though we could expect same results on such a simple case...<br>
  The result is confirmed by increasing precision:<br>
  {{{(7 asArbitraryPrecisionFloatNumBits: 70) ln.}}}<br>
  -> *(ArbitraryPrecisionFloat readFrom: '1.945910149055313305106' readStream numBits: 70)*<br>
  The value rounded to 53 bits is correct:<br>
  {{{(7 asArbitraryPrecisionFloatNumBits: 70) ln asFloatD storeString.}}}<br>
  -> *'1.9459101490553132'*<br>
  Note, that the last digit is not guaranteed to match correct decimal rounding, the decimal representation is only expected to give back exactly the same value when rounded to base 2, and both 1.9459101490553132 and 1.9459101490553133 do.<br>
  The difference is less than 1/2 ulp for the ArbitraryPrecisionFloat result:<br>
  {{{((7 asArbitraryPrecisionFloatNumBits: 70) ln - (7 asArbitraryPrecisionFloatNumBits: 53) ln) / (7 asFloatD ln ulp).}}}<br>
  -> *(ArbitraryPrecisionFloat readFrom: '0.32983' readStream numBits: 70)*<br>
  And more than 1/2 ulp for the FloatD result<br>
  {{{((7 asArbitraryPrecisionFloatNumBits: 70) ln - (7 asFloatD ln)) / (7 asFloatD ln ulp).}}}
  -> *(ArbitraryPrecisionFloat readFrom: '-0.67017' readStream numBits: 70)*<br>
  Note that *#ulp* is a Squeakism meaning unit of least precision, but you might find equivalent messages in other dialects.
That's all for this short introduction, let's hope that you'll find a good usage of this class, or at least that these examples will provide educational benefits.